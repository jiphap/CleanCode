# CleanCode

## intro

여러 프로젝트를 진행하며 처음에 느낀 점은 프로젝트는 시간과의 싸움이라는 것이었다. 제한되어 있는 시간에 스케줄에 맞춰서 작업을 완수해야 하여 운영팀으로 인수인계를 성공적으로 완료하면 끝이나는 패턴이었다. 처음에는 고객의 원하는 요구사항을 충족시켜 구성을 하는 것까지 중점을 두고 많은 시간을 할애했었다. 지금 생각해보면 안일한 부분이었지만 처음에는 구성에 많은 중점을 두고 나머지 사항은 소홀하였었던 것 같다. 수행하는 프로젝트의 기존에 짜인 코드들을 보고 나도 저 정도만 신경 쓰면 되겠 지란 생각에서 출발을 했지만 정말 안 좋은 생각이었던 것 이다. 
요즈음 느낀 사항들이지만 내가 작성하여 놓은 코드에 변화가 필요하다고 느끼게 되었다. 내가 만든 코드는 나중에는 다른 사람들이 보완과 운영을 할 것이고 후의 사람들을 위해서 나의 코드들이 좀더 깔끔하고 형식에 맞춰진 방식으로 변해야 한다고 생각을 하였다. 보기도 좋은 떡이 먹기도 좋다고 좀더 형식화되고 잘 구성된 코드도 좀더 고급스럽게 그리고 사람들이 더 빠르게 이해할 수 있을 거라고 믿고 있다. 프로젝트 수행 중에도 느꼈지만 작성자가 어지럽게 만든 코드는 그 뜻을 찾는데 많은 시간을 소요했으며 정말 불편했던 경험들이 많았었다. 나도 이러한 느낀 점을 거울삼아 요번시간을 이용하여 클린코드라는 책을 읽어보고 나의 코드들을 어떻게 발전시키는지 알아보는 시간으로 삼고자 한다.

## 1. 의미 있는 이름

프로젝트 수행 중에 우리는 많은 변수, 클래스, 함수 등의 이름을 부여할 일이 생긴다. 물론 수행전에 이름들이 미리 명칭 되어있으면 좋지만 보통은 수행 중에 명칭을 부여하는 상황이 많이 있다. 명칭은 의도가 분명하게 드러나는 식으로 지어져야 한다고 나온다. 
예전에 변수를 설정할 때 int d (날짜) 라는 식으로 많이 설정을 했던 경험이 있었다. int d를 createDate 등으로 변경하여 사용할 경우 우리는 주석을 보지 않아도 의도된 명칭으로 변수가 보여주고자 하는 정보를 알 수 있게 된다. 그리고 의도된 명칭으로 명명을 하다 보면 가끔은 비슷한 명칭들을 사용한 적이 있는 경험이 있다. 예를 들어 getActiveAccount(), getActiveAccounts(), getActiveAccountInfo() 등 흡사한 명칭은 많은 혼란을 초래하며 명칭의 의도를 찾는데 많은 시간을 소요시킨다. 작성자가 아무리 똑똑해도 기억력에는 한계가 있다. 나중에는 작성자 조차도 헷갈려 할 수 있기 때문에 이와 같은 명명방법은 피해야할 것이다. 
클래스와 메서드의 명칭을 명명할 때 생각해 봐야하는 사항들도 책에서 나온다. 
클래스의 경우 동사의 사용을 자제하고 명사 혹은 명사구를 사용하라고 하고 있다. Customer, WikiPage, Account, AddressParser 등과 같은 명칭을 사용하고 Manager, Processer, Data, Info 와 같은 단어는 피하라고 나와있다. 
메서드의 경우 save, deletePage와 같이 동사나 동사구를 이용하라고 말한다. 접근자, 변경자, 조건자의 경우 get, set, is로 시작을 하는 방법이 좋다고 한다. 생성자를 중복정의 할 때는 팩토리 메서드를 사용하고 메서드는 인수를 설명하는 이름을 사용한다. 그리고 생성자 사용을 제한하려면 해당생성자를 private으로 선언을 한다.  
Complex fulcrumPoint = new Complex(23.0);  
Complex fulcrumPoint = Complex.FromRealNumber(23.0); 
첫번째의 예시 보다는 두번째의 예시를 사용하는 것이 더 좋다고 나온다.
마지막으로 불필요한 맥락을 없애라고 한다. Gas Station Delux라는 어플리케이션을 작성한다고 해서 클래스 이름의 앞에 GSD를 붙일 필요가 없다고 한다. G를 입력하고 자동완성을 누를 경우 모든 클래스가 나타나는 등 효율적이지 못한 경우가 있기 때문이다. a처럼 접두어를 붙이는 것은 모듈의 재사용 관점에서도 좋지 못하다. 재사용하려면 이름을 바꿔야 한다. GSDAccountAddress를 사용하는 대신에 Address 라고 정해도 충분하다고 적혀 있다. 
이름의 경우 가장 기본적이도 가장 먼저 하는 작업이 아닌가 생각이 든다. 당연한 사항도 있지만 계속 반복된 작업을 하다 보면 내용을 잊고 작업을 진행하기로 한다. 가장 기본적이고 프로그램의 토대인만큼 항상 기억하며 상기시켜야 하는 사항인 것 같다.

## 2. 함수

함수는 프로그램을 구성하는 가장 기본적인 요소 중 하나라고 생각한다. 단순히 동작만을 하는 것만이 아닌 구조적으로 클린 하게 잘 짜인 함수를 구성할 필요가 있다고 많이 느꼈었다. 남이 전에 구성했던 코드 중 잘 구성된 코드는 속독성이 빨랐고 이해 또한 쉬웠다. 하지만 아닌 코드는 보기도 어려웠고 이해하기에도 많은 시간이 필요한 경우가 있었다. 읽기 쉽고 이해하기 쉬운 함수는 어떻게 구성이 되는지 이 책을 이용하여 알아보기로 했다. 
* 1) 규칙은 작게 만들어라. 
길고 장황 하게 짜인 경우 간결하게 만들어야 한다고 한다. If/else/while 문에 들어가는 블록은 한 줄이 어야 하고 각 함수 별 들여쓰기 수준이 2단을 넘어서지 않으며, 각 함수가 명백하다면 함수는 더욱 읽고 이해하기 쉬워진다고 말하고 있다. 
* 2) 한가지만 해라.
책에서는 ‘함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지 만을 해야 한다.’ 고 말하고 있다. 지정된 함수 아래 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 하는 것이다. 만일 함수안에서 함수를 여러 섹션으로 나눌 수 있고 의미 있는 다른 이름으로 추출이 가능하다면 그 함수는 여러가지 작업을 하는 것이다. 
* 3) 함수 당 추상화 수준은 하나로
함수가 한가지만 잘하게 만들려면 함수내 모든 문장의 추상화 수준이 동일해야 한다. 한 함수에 추상화 수준이 섞이면 사람들이 혼란스러워 할 수 있다. 예를 들어 특정 표현이 근본 개념인지 혹은 세부사항인지 구분이 어려워진다. 
코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 내려가기 규칙으로 함수 추상화 부분이 한번에 한 단계씩 낮아지는 것이 가장 이상적이다. 그렇게 되면 일정한 추상화 수준을 유지한다.
* 4) 서술적인 이름을 사용하라
서술적인 이름으로 구현해야 한다는 것도 책에서 말하고 있다. 작은 함수인 경우 기능이 명확하므로 이름을 붙이기 쉬우며 일관성이 있는 서술형 이름을 사용한다면 코드를 순차적으로 이해하기도 쉬워질 수 있다고 설명한다. 또한 개발자 머리에서도 설계가 뚜렷해지므로 추후 개선시에도 훨씬 좋은 효과를 볼 수 있다.
* 5) 함수 인수
함수에서 이상적인 인수 개수는 0개라고 말한다. 다음은 1개 그리고 다음은 2개이다. 3개는 되도록 피하고 4개는 특별한 이유가 필요하다고 나온다. 출력 인수는 입력 인수 보다 이해하기가 어렵다. 함수에다 인수로 입력을 넘기고 반환 값을 받는 개념에 익숙하지만 함수에서 인수로 결과를 받으리라 기대를 하지 않기 때문에 최선은 인수가 없는 경우이고 차선은 1개로 하는 것이 최선이다. 몇 가지 케이스 이외에는 단항 함수는 피하는 것이 좋다고 설명을 한다.
    - 1.	인수에 질문을 던지는 경우
boolean fileExists(“MyFile”);
    - 2.	인수를 뭔가로 변환해 결과를 변환하는 경우
InputStream fileOpen(“MyFile”);
    - 3.	이벤트 함수일 경우 (이 경우에는 이벤트라는 사실이 코드에 명확하게 드러나야 한다.)
플래그 인수인 경우 bool값을 넘기는 것 자체가 여러가지 일을 처리할 것이라고 보여주는 것이기 때문에 사용하면 안된다. 
단항 함수의 경우 함수와 인수가 동사/명사 쌍으로 이뤄져야한다고 말해준다. 
예) writeField(name); 함수이름에 키워드를 추가하면 인수 순서를 기억할 필요도 없어질 수 있기 때문에 이런 식으로 작성하는 것이 좋다고 한다. 
예) assertExpectedEqualsActual(expected, actual); 
오류코드의 사용보다는 try/catch 예외처리를 하면 오류코드의 처리가 원래의 코드와 분리되므로 훨씬 깔끔한 코드를 구현할 수 있다. 오류의 처리도 한가지의 작업에 속해 있기 때문에 오류를 처리하는 함수를 따로 작성하여 관련작업만 처리할 수 있도록 해야 한다.
* 6) 부수 효과를 일으키지 마라
모든 사항들이 중요하겠지만 나는 여기서 반복하지 마라라는 항목에 대해 깊은 생각을 해야 한다고 생각한다. 가장 기본적인 사항이만 여러 항목에 반복되는 알고리즘이 다른 코드들과 섞이면 캐치하기도 어렵기 때문에 사전에 그런 사항을 만들지 말아야한다고 생각한다. 예를 들어 네 곳의 다른 장소에 반복적인 함수가 있으면 변경을 할 때에도 네 번이나 작업을 해야 하기 때문이다. 시간의 소요도 많을 뿐만 아니라 한곳이라도 놓치면 에러를 생성시킬 수 있기 때문에 정말로 조심하고 확인해야할 사항인 거 같다.
* 7) 구조적 프로그래밍
다익스트라의 구조적 프로그래밍의 원칙을 따르자면 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나여야 된다. 즉, 함수는 return문이 하나여야 되며, 루프 안에서 break나 continue를 사용해선 안되며 goto는 절대로 사용하지 말자고 말을 한다. 이경우는 함수가 클 경우에만 상당 이익을 제공하므로, 함수를 작게 만든다면 오히려 여러차례 사용하는 것이 함수의 의도를 표현하기 쉬워진다. 위에 나온 원칙은 함수가 아주 클 때만 상당한 이익을 제공하므로 함수를 작게 만든다면 간혹 return, break, continue를 사용해도 괜찮고 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다고 저자는 이야기하고 있다.
함수를 짜는 행위는 책에서도 나오지만 한번에 나오는 것이 아니다. 글짓기 같이 위의 사항을 항상 생각하며 몇 번을 돌아와서 확인하며 다듬고 또 다듬어야 한다고 생각을 한다. 책에서도 몇번의 수정 끝에 결과가 나온다고 하니 나 같은 경우도 많은 수정 절차가 필요할것이다.

## 3. 주석

프로젝트 수행 중 우리는 수없이 많은 주석을 작성하였고 또 보았다. 주석은 꼭 필요한 사항이라는 것은 인정하지만 가끔은 너무 많은 정보를 기입하느라 오히려 주석이 주가 되는 상황까지 본적 있는 것 같다. 
책에서는 ‘잘 달린 주석은 어떤 정보보다 유용하다. ‘고 한다. 하지만 책에서는 주석은 필요악이다 라고도 말을 한다. 주석은 코드로 의도를 표현하지 못해, 실패를 만회하기 위해 쓰는 것, 주석은 언제나 실패를 의미한다 고한다. ‘주석을 무시하는 이유가 무엇이냐고? 주석이 오래될수록 코드에서 멀어져서 거짓말을 하게 될 가능성이 커지기 때문이다. 코드는 유지보수를 해도, 주석을 계속 유지보수하기란 현실적으로 불가능하기 때문이다.’ 라고 표현을 했다. 무슨 의도로 표현을 했는지는 알지만 나는 표현이 너무 한쪽으로 치우쳐 있다고 생각한다. 맞는 형태로 기입된 주석은 어느 정보보다 도움이 된다고 생각을 한다. 하지만 문제는 모든 사람들이 맞는 형태로 기입 하는 법을 모른다는 것 그래서 엉터리로 기입된 주석은 오히려 함정이 되어 많은 어려움을 유발할 수 있다는 것이다. 책에서는 주석으로 설명을 하는 시간보다 코드로 의도를 보여주는 방식으로 접근하라고 나와있다.
* 1) 예) // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. 
if ((emplotee.flags & HOURLY_FLAG) && (employee.age > 65)
* 2) 예) 	if (employee.isEligibleForFullBenefits())
함수이름으로 주석이 필요없이 의도를 보여준다고 나와있다. 나는 조금 다르게 생각한다. 물론 함수이름으로 표현이 최선의 방법인 것을 이해를 하고 동의를 하나 이와 같은 이야기는 영어권에서 더욱 공감을 얻을 상황인 거 같다. 과연 우리나라 개발자 중 변경된 함수를 보고 그 뜻을 한번에 이해할 수 있을지 궁금하다. 나는 이와 같은 상황에서는 함수의 이름 변경과 주석 또한 추가해야 한다고 생각을 한다.   
책에서는 좋은 주석 즉 필요한 주석의 셜명이 되어있다. 
    - 1) 법적인 주석 즉 각 소스 파일 첫머리에 들어가는 저작권 정보와 소유권 정보 등이 표시 되어있는 주석이다. 
    - 2) 정보를 알려주는 주석
// 테스트 중인 Responder 인스턴스를 반환
protected abstract Responder responderInstance();
    - 3) 의도를 설명해주는 주석 
// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. 
for (int i = 0; i > 2500; i++) {
    WidgetBuilderThread widgetBuilderThread = 
        new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
    Thread thread = new Thread(widgetBuilderThread);
    thread.start();
}
    - 4) 결과를 경고하는 주석
// 여유 시간이 충분하지 않다면 실행하지 마십시오.
public void _testWithReallyBigFile() {}  
    - 5) TODO 주석 
TODO 주석은 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기입한다. 더 이상 필요 없는 기능을 삭제하라는 알림, 누군가에게 문제를 봐 달라는 요청, 더 좋은 이름을 떠올려 달라는 부탁, 앞으로 발생할 이벤트에 맞춰 코드를 고치라는 주의 등에 유용하다.
    - 6) 중요성을 강조하는 주석 
String listItemContent = match.group(3).trim();
// 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.
// 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. 

위와 같이 필요성이 있는 주석과는 반대로 필요하지 않은 또는 잘못된 상황에서 사용하는 나쁜 주석의 예시와 항목이 있다.
* 1) 주절거리는 주석 
특별한 이유 없이 기입된 주석을 이야기한다. 주석의 의미를 알아내기 위해 다른 코드를 뒤져보는 수밖에 없는 주석, 이해가 안되어 다른 모듈까지 뒤져야 하는 주석은 제대로 된 주석이 아니다. 또한 코드내용을 그대로 중복하는 주석도 필요 없는 주석이라고 나온다.
* 2) 오해할 여지가 있는 주석
우리는 주석을 기입할 때 정확한 정보, 클리어한 정보를 넣어 줘야한다. 헷갈리거나 잘못된 정보로 인하여 프로그래머는 잘못된 함수를 호출해 개발, 보완 작업에 지장이 생기기 때문이다.
* 3) 의무적으로 다는 주석
모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. 아래와 같은 주석은 아무 가치도 없다고 말하고 있다.
* 4) 이력을 넣는 주석
 변경 이력 (11-Oct-2001부터)
 11-Oct-2001 : 클래스를 다시 정리하고 새로운 패키징
 05-Nov-2001: getDescription() 메소드 추가
 이하 생략
이력이 기입 되어있는 프로그램을 몇 번 본적이 있다. 이력이 쌓이면 정말로 많은 공간을 차지하며 별로 좋아 보이지 않았다. 이력을 남기는 취지는 이해하겠으나 SVN에 업데이트 할 때 이력과 수정내용을 기입해서 커밋을 하면 되는게 아닌가 란 생각을 많이 했던 것 같다. 
* 5) 위치를 표시하는 주석
이런 주석은 가독성만 낮추므로 제거해야 마땅하다. 특히 뒷부분에 슬래시로 이어지는 잡음은 제거하는 편이 좋다. 너무 자주 사용하지 않을 때만 배너는 눈에 띄며 주위를 환기한다. 그러므로 반드시 필요할 때 아주 드물게 사용하는 편이 좋다고 말하고 있다.
* 6) 주석으로 처리한 코드
‘우리는 우수한 소스 코드 관리 시스템을 사용하기 때문에 우리를 대신에 코드를 기억해준다. 그냥 삭제하라. 잃어버릴 염려는 없다. 약속한다’ 라고 책에서 나와있다. 나는 이 생각에 조금은 반대한다.  주석으로 처리한 코드를 깔끔하게 넣고 어느 샘플에 사용했다 라는 식으로 있으면 테스트나 이해 시 많은 도움이 됐었던 기억이 있다. 물론 함수의 변경 시 그에 맞는 코드를 넣고 관리해야 하는 점이 있다. 관리시스템을 일일이 보는 수고 보다 이런 점이 리스크는 있지만 빠르고 편한 거 같다.
* 7) 전역정보
주석을 달아야 한다면 근처에 있는 코드만 기술하라. 시스템의 전반적인 정보를 기술하지 마라. 해당 시스템의 코드가 변해도 아래 주석이 변하리라는 보장은 전혀 없다. 그리고 심하게 중복된 주석도 확인하자라고 되어있다. 
주석의 경우 많은 사항을 배웠지만 그 중에서 공감이 되는 점 그리고 동의를 못하는 점들도 있었다. 하지만 다시 생각해보면 관리의 관점에서 보면 책에 나온 점들이 맞는 사항이라고 느끼고 있다. 다시한번 이사항을 복습을 하며 후임 관리자를 위해서도 적절한 주석들을 넣어야 한다는 점을 다시한번 깨닫는다. 

## 4. 오류 처리

프로그램을 개발하면 오류는 필연적으로 나오게 된다. 오류처리는 그만큼 중요하다. 하지만 로직을 헷갈리게 만드는 오류 처리는 더 안 좋다고 볼 수 있다. 
* 1) 오류코드보다 예외를 사용하라.
예전 에는 exception을 제공하지 않는 프로그래밍 언어들이 있었다. 그런 경우에는 에러 flag를 set하거나 에러 코드를 리턴, 호출하는 측에서 예외처리를 해줘야 했다. 이러한 방식의 문제는 예외처리를 잊어버리기 쉽고 로직을 헷갈리게 하기 쉬운 일들이 생긴다. 책에서는 그러한 이유로 exception을 사용하라고 말하고 있다. 그렇게 하면 겉보기에만 아름다운 코드가 되는게 아니라 ‘실제 로직’과 ‘예외처리’ 부분이 나뉘어져 필요한 부분에 집중할 수 있게 된다고 설명을 하고 있다.
* 2) try-catch-finally 문부터 작성을 해라.
책에서는 try문은 transaction처럼 동작하는 실행코드로, catch문은 try문에 관계없이 프로그램을 일관적인 상태로 유지하도록 한다고 말한다. 이렇게 함으로 코드의 ‘Scope 정의’가 가능해진다.
* 3) 미확인(Unchecked) 예외를 사용하라.
확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 예외처리에 드는 비용대비 이익을 생각을 해봐야한다고 나온다. 특정 메소드에서 checked exception을 throw하고 3단계(메소드 콜)위의 메소드에서 그 exception을 catch한다면 모든 중간단계의 모든 메소드에 exception을 정의해야 하는데 자바인 경우 메소드 안에 throw 절을 붙이는 등의 행위를 해야 한다. Throw 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화 또한 깨지게 된다. 아주 중요한 라이브러리를 작성한다는 경우에는 모든 예외를 잡아야 하지만 일반적 어플리케이션 기준으로 보면 득보다 실이 많다고 이야기를 하고 있다.
* 4) 호출자를 고려해 예외 클래스를 정의해라 
어플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이다. 써드파티 라이브러리를 사용하는 경우 그것들을 wrapping함으로써 
  - 1. 라이브러리 교체 등의 변경이 있는 경우 대응하기 쉬워진다.
  - 2. 라이브러리를 쓰는 곳을 테스트할 경우 해당 라이브러리를 가짜로 만들거나 함으로써 테스트하기 쉬워진다. 
  - 3. 라이브러리의 api 디자인에 종속적이지 않고 내 입맛에 맞는 디자인을 적용할 수 있다. 
라는 장점 들이 있다.
보통 특정 부분의 코드에는 exception 하나로 충분히 예외처리 할 수 있으며 한 exception만 잡고 나머지 하나는 다시 throw하는 경우 등 정말 필요한 경우에만 다른 exception 클래스를 만들어 사용하면 된다고 나온다.
* 5) null을 반환 하지마라
책에서는 null을 반환하는 코드는 일거리를 늘리고 호출자에게 문제는 떠넘기는 행위라고 나와있다. 극단 적인 상황으로 누구 하나가 null의 확인을 빼먹으면 프로그램이 통제불능의 상황까지 일어 날수도 있다고 한다.
Null을 반환하고 싶은 경우는 special case object를 반환하라고 나와있다. 서드파티 라이브러리에서 null을 반환할 가능성이 있는 메서드가 있다면 Exception을 던지거나 Special Case object를 반환하는 메소드로 래핑하라고 한다.
* 6) null을 전달 하지마라
Null을 반환하는 방식도 나쁘지만 null을 전달하는 방식 또한 나쁜 방식이다. null을 메서드의 파라미터로 넣어야 하는 API를 사용하는 경우가 아니면 null을 메서드로 넘기면 안된다고 되어있다. 그 이유는 일반적으로 대다수의 프로그래밍 언어들은 파라미터로 들어온 null에 대해 적절한 방법을 제공하지 못하고 가장 이상적인 해법은 null을 파라미터 값으로 받지 못하도록 하는 것이다.
책에서는 오류 처리에 관해 이렇게 결론을 내고 있다. ‘깨끗한코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.’ 위에 사항들은 한번 다시 생각해봐야하는 사항들 같다. 프로그램의 실효성 그리고 최대한의 리스크를 없애기 위한 사항들이며 프로그램의 구동의 완벽성을 위한 중요한 부분이라고 생각을 한다.

## 5. 단위 테스트 

책에서는 1997년만 해도 TDD(Test Driven Development)라는 개념을 아무도 몰랐다. 우리들 대다수에게 단위 테스트란 자기 프로그램이 '돌아간다'는 사실만 확인하는 일회성 코드에 불과했다. 지금은 애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 더 늘어나는 추세다. 하지만 테스트를 추가하려고 급하게 서두르는 와중에 많은 프로그래머들이 제대로 된 테스트 케이스를 작성해야 한다는 좀 더 미묘한(그리고 더욱 중요한) 사실을 놓쳐버린 형상들이 일어났다고 말하고 있다.
* 1) TDD 법칙 
TDD가 실제 코드를 짜기 전에 단위테스트부터 짜라고 요구한다는 사실을 가지고 있고 이러한 점은 빙산의 일각에 불과하다. 책에서는 세가지의 법칙을 보여주고 있다.
  - 1. 첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
  - 2. 둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  - 3. 셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
위 세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다. 테스트 코드와 실제 코드가 함께 나오고 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.
이렇게 일하면 매일 수십 개, 매달 수백 개, 매년 수천 개에 달하는 테스트 케이스가 나온다. 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나온다. 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다는 문제점이 있기도 하다.
* 2) 깨끗한 테스트 코드 유지하기
테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다. 그리고 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍쳐가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까 두렵기 때문이다. 하지만 테스트 케이스가 있다면 공포는 사실상 사라진다. 테스트 커버리지가 높을수록 공포는 줄어든다. 아키텍처가 부실한 코드나 설계가 모호하고 엉망인 코드라도 별다른 우려 없이 변경할 수 있다. 아니, 오히려 안심하고 아키텍처와 설계를 개선할 수 있다고 한다. 그러므로 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍쳐를 최대한 깨끗하게 보존하는 열쇠라고 볼 수 있다. 따라서 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다. 테스트 코드가 지저분할수록 실제 코드도 지저분해 진다. 결국 테스트 코드를 잃어버리고 실제 코드도 망가지는 사태를 초래할 수 있다. 
* 3) 깨끗한 테스트 코드
각 테스트는 명확히 세 부분으로 나눠진다. 첫 부분은 테스트 자료를 만든다. 두 번째 부분은 테스트 자료를 조작하며, 세 번째 부분은 조작한 결과가 올바른 지 확인한다. 잡다하고 세세한 코드를 거의 다 없앴다는 사실에 주목한다. 테스트 코드는 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다. 그러므로 코드를 읽는 사람은 온갖 잡다하고 세세한 코드에 주눅들고 헷갈릴 필요 없이 코드가 수행하는 기능을 재빨리 이해한다.
테스트 API코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르게 표현을 한다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다고 한다. 실제 환경이 아니라 테스트 환경에서 돌아가는 코드이기 때문인데, 실제 환경과 테스트 환경은 요구사항이 판이하게 다르기 때문이다.
* 4) 테스트 당 assert 하나
JUnit으로 테스트 코드를 짤 때 함수마다 assert를 단 하나만 사용해야 한다고 주장하는 학파가 있다. 가혹하다 여길지 모르지만 확실히 장점이 있다. assert가 하나라면 결론이 하나기 때문에 코드를 이해하기 빠르고 쉽기 때문이다. 하지만 책에서는 어쩌면 ‘테스트 함수마다 한 개념만 테스트하라’는 규칙이 더 낫겠다고 이야기를 한다. 개념 세 개를 테스트해야 하는 하나의 함수보다는 독자적인 테스트 세 개로 쪼개진 함수들이 맞다고 생각을 한다고 한다. 이유는 이를 한 함수로 몰아넣으면 후임자가 각 절이 거기에 존재하는 이유와 각 절이 테스트하는 개념을 모두 이해해야 하기 때문이다. 책에서 말하는 가장 좋은 솔루션은 ‘개념 당 assert 문 수를 최소로 줄여라’와 ‘테스트 함수 하나는 개념 하나만 테스트하라’ 라고 정의를 하였다.
* 5) FIRST
깨끗한 테스트에는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 FIRST가 된다.
    - 1. 빠르게 Fast: 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다는 말이다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지 못하며 결국 코드 품질이 망가지기 시작한다.
    - 2. 독립적으로 Independent: 각 테스트를 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.
	 - 3. 반복가능하게 Repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 버스를 타고 집으로 가는 길에 사용하는 노트북 환경(네트워크가 연결되지 않은)에서도 실행할 수 있어야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.
    - 4. 자가검증하는 Self-Validating: 테스트는 bool값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알리고 로그 파일을 읽게 만들어서는 안 된다. 통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.
    - 5. 적시에Timely: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명 날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.
테스트 코드는 실제 코드만큼이나 프로젝트에 중요한 부분이다고 생각한다. 책에서 나왔듯이 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 테스트 코드는 지속적으로 깨끗하게 관리가 필수라고 나온다. 실제로 테스트가 제대로 되었고 잘 구성된 코드들을 보면 맘이 놓이면서 거부감 없이 변경과 보완을 할 수 있다. 또한 개발 중에 놓친 사항들도 확인할 수 있으니 중요한 사항이다. 위의 항목들과 같이 적용을 해보며 테스트를 신중히 진행을 해야 할 거 같다.

## 6. 클래스 

* 1) 클래스 체계
표준 자바 관례에 따르면 가장 먼저 변수 목록이 나온다. Static(정적), public(공개) 함수가 있다면 맨처음에 나온다.  다음으로 private(정적 비공개) 변수가 나오며 이어서 인스턴스 변수가 나온다.
변수 목록 다음에는 공개함수가 나오며 비공개함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉 추상화 단계가 순차적으로 내려간다. 
-캡슐화
변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 하는 것은 아니다. 테스트는 중요하므로 테스트를 위해 protected로 선언해서 접근을 허용하기도 한다. 하지만 비공개 상태를 유지할 온갖 방법을 강구하고, 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다고 설명을 하고 있다.
* 2) 클래스는 작아야 한다
함수와 같이 책에서는 크기를 강조하고 있다. 클래스 또한 작아야 한다고 주장을 하고 있다. 함수는 행수로 측정을 하지만 클래스인 경우는 맡은 책임으로 크기를 측정한다.
클래스 이름은 해당 클래스 책임을 기술해야 된다고 나와있다. 작명은 클래스 크기를 줄이는 첫번째 관문이며 클래스의 간결한 이름이 떠오르지 않는다면 클래스 책임이 너무 많기 때문이다.
    - 1. 단일책임의 원칙 
단일책임의 원칙은 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다. 변경할 이유를 찾다 보면 추상화하기도 쉬워진다. 단일책임 원칙은 객체지향설계에서 더욱 중요한 개념이고, 지키기 수월한 개념인데, 개발자가 가장 무시하는 규칙 중 하나이다. 돌아가는 소프트웨어가 작성되면 깨끗하고 체계적인 소프트웨어라는 다음 관심사로의 전환이 필요하다. 작은 클래스가 많은 시스템이든, 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품은 그 수가 비슷하다. 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다고 나온다. 작은 클래스는 각자 맡은 책임이 하나이고, 변경해야 할 이유가 하나이며, 다른 작은 클래스와 협력해
시스템에 필요한 동작을 수행한다.
    - 2. 응집도 
클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 하며 일반적으로 메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 더 높아진다. 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높지만, 이런 클래스는 가능 하지도 바람직 하지도 않다. 하지만 될 수 있으면 가능한한 응집도가 높은 클래스를 지향해야 한다.  응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미이기 때문이다. 수를 작게, 매개변수 목록을 짧게 라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 새로운 클래스를 쪼개야 한다는 신호로 보면 된다. 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 나눠주는데 응집도를 유지하면 작은 클래스 여럿이 나온다. 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다. 예를 들면
변수가 아주 많은 큰 함수가 하나 있다
--> 큰 함수 일부를 작은 함수로 빼내고 싶다
--> 빼내려는 코드가 큰 함수에 정의된 변수를 많이 사용한다
--> 변수들을 새 함수에 인수로 넘겨야 하는 건 아니다.
--> 변수들을 클래스 인스턴스 변수로 승격시키면 인수가 필요 없게 되지만 응집력은 낮아진다.
--> 몇몇 함수가 몇몇 인스턴스 변수만 사용한다면 독자적인 클래스로 분리해도 된다!
가장 먼저 원래 프로그램의 정확한 동작을 검증하는 테스트 슈트를 작성하며 그 후 다음 한번에 하나씩 여러 번에 걸쳐 코드를 변경하는 작업 후, 코드를 변경할 때 마다 테스트를 수행해 원래 프로그램과 동일하게 동작하는지 확인을 해야 한다.
* 3) 변경하기 쉬운 클래스
클래스 일부에서만 사용되는 비공개 메서드는 코드 개선의 잠재적인 여지를 시사한다. 깨끗한 시스템은 클래스를 체계적으로 관리해 변경에 따르는 위험을 최대한 낮춘다.
    - 1. 변경으로부터 격리
OOP입문에서 concrete 클래스와 abstract 클래스가 있는데, concrete 클래스에 의존(상세한 구현에 의존)하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 그래서 인터페이스와 abstract 클래스를 사용해 구현이 미치는 영향을 격리시켜야 한다. 상세한 구현에 의존하는 코드는 테스트가 어려우므로 추상화를 통해 테스트가 가능할 정도로 시스템의 결합도를 낮춤으로써 유연성과 재사용성도 더욱 높아진다. 결함도가 낮다는 말은 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 뜻이라고 나와있다.

## 7. 창발성

책에서 저자는 켄트 벡이 제시한 단순한 설계 규칙 네 가지가 소프트웨어 설계 품질을 크게 높여준다고 믿고 있다. 켄트 벡이 제시하는 설계규칙은 다음과 같다.
1. 모든 테스트를 실행한다.
2. 중복을 없앤다.
3. 프로그래머 의도를 표현한다.
4. 클래스와 메서드 수를 최소로 줄인다. 
* 1) 단순한 설계 규칙 1: 모든 테스트를 실행하라
테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아지게 되어 크기가 작고 목적 하나만 수행하는 클래스가 나온다. 테스트를 더 많이 작성하면 할수록 프로그래머가 더 테스트하기 간단하게 코드를 작성할 수 있게 도와준다. 따라서 철저한 테스트가 가능한 시스템을 만들면 더 나은 설계가 얻어진다. 결합도가 높으면 테스트 케이스를 작성하기 어렵다. 그러므로, 테스트 케이스를 많이 작성할수록 개발자는 DIP와 같은 원칙을 적용하고 의존성 주입(Dependency Injection), 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다. 따라서 설계 품질은 더욱 높아진다.) 놀랍게도 ‘테스트 케이스를 만들고 계속 돌려라’라는 간단하고 단순한 규칙을 따르면 시스템은 낮은 결합도와 높은 응집력이라는, 객체 지향 방법론이 지향하는 목표를 저절로 달성한다. 즉, 테스트 케이스를 작성하면 설계 품질이 높아진다고 나와있다.
* 2) 단순한 설계 규칙 2~4: 리팩터링
테스트 케이스를 모두 작성했다면 코드를 점진적으로 리팩터링 해야 한다. 코드 몇 줄을 추가할 때마다 잠시 멈추고 설계를 조감한다. 새로 추가하는 코드가 설계 품질을 낮춘다면 깔끔히 정리한 후 테스트를 돌려 기존 기능을 깨뜨리지 않았다는 사실을 확인해야한다. 테스트 케이스가 있으니 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다고 말하고 있다. 이 단계는 단순한 설계 규칙 중 나머지 3개를 적용해 중복 제거, 프로그래머 의도 표현, 클래스 메서드 축소 등등을 할 수 있다.
    - 1. 중복을 없애라 
우수한 설계에서 중복은 커다란 적이다. 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문이다. 중복은 여러 가지 형태로 표출된다. 똑같은 코드는 당연히 중복이다. 비슷한 코드는 더 비슷하게 고쳐주면 리팩터링이 쉬워진다. 구현 중복도 중복의 한 형태다. 깔끔한 시스템을 만들려면 단 몇 줄이라도 중복을 제거하겠다는 의지가 필요하다. '소규모 재사용'은 시스템 복잡도를 극적으로 줄여준다. 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다. 
    - 2. 표현하라
소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다. 코드를 변경하면서 버그의 싹을 심지 않으려면 유지보수 개발자가 시스템을 제대로 이해해야 한다. 하지만 시스템이 점차 복잡해지면서 유지보수 개발자가 시스템을 이해하느라 보내는 시간은 점점 늘어나고 동시에 코드를 오해할 가능성도 점점 커진다. 그러므로 코드는 개발자의 의도를 분명히 표현해야 한다. 개발자가 코드를 명백하게 짤수록 다른 사람이 그 코드를 이해하기 쉬워진다. 그래야 결함이 줄어들고 유지보수 비용이 적게 든다. 
        + 첫째, 좋은 이름을 선택한다. 이름과 기능이 완전히 딴판인 클래스나 함수로 개발자를 놀라게 해서는 안 된다. 
        + 둘째, 함수와 클래스 크기를 가능한 한 줄인다. 작은 클래스와 작은 함수는 이름 짓기도 쉽고, 구현하기도 쉽고, 이해하기도 쉽다. 
        + 셋째, 표준 명칭을 사용한다. 예를 들어, 디자인 패턴은 의사소통과 표현력 강화가 주요 목적이다. 클래스가 COMMAND나 VISITOR와 같은 표준 패턴을 사용해 구현된다면 클래스 이름에 패턴 이름을 넣어준다. 그러면 다른 개발자가 클래스 설계 의도를 이해하기 쉬워진다.
        + 넷째, 단위 테스트 케이스를 꼼꼼히 작성한다. 테스트 케이스는 소위 '예제로 보여주는 문서'다. 다시 말해, 잘 만든 테스트 케이스를 읽어보면 클래스 기능이 한눈에 들어온다. 
흔히 코드만 돌린 후 다음 문제로 직행하는 사례가 너무도 흔하다. 나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만들려는 충분한 고민은 거의 찾기 어렵다. 하지만 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심해야 만한다. 함수와 클래스에 조금 더 시간을 투자해야 한다. 더 나은 이름을 선택하고, 큰 함수를 작은 함수 여럿으로 나누고, 자신의 작품에 조금만 더 주의를 기울여야한다.
    - 3. 클래스와 메서드 수를 최소로 줄여라
때로는 무의미하고 독단적인 정책 탓에 클래스 수와 메서드 수가 늘어나기도 한다. 클래스마다 무조건 인터페이스를 생성하라고 요구하는 구현 표준이 좋은 예다. 자료 클래스와 동작 클래스는 무조건 분리해야 한다고 주장하는 개발자도 좋은 예다. 가능한 독단적인 견해는 멀리하고 실용적인 방식을 택해야 한다. 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다. 하지만 이 규칙은 간단한 설계 규칙 네 개 중 우선순위가 가장 낮다. 다시 말해, 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 뜻이다. 
즉 창발적 설계라는 뜻이 처음에는 모호 했는데 읽고 보니 어떤 규칙과 원칙에 따라 설계를 하게 되면, 그것들이 모여 아주 좋은 거시적 설계를 이룬다고 생각을 하게 만들었다. 이 책에서 소개하는 기법은 저자들이 수십 년 동안 쌓은 경험을 보여준다고 생각을 한다. 단순한 설계 규칙을 따른다면 (오랜 경험 후에 익힐) 우수한 기법과 원칙을 단번에 활용할 수 있지 않을까 생각을 한다. 

## Conclusion
이 책을 읽으면서 많은 노하우와 원칙들을 배울 수 있었다. 그 중에서도 가장 많이 든 생각은 차근차근히 생각과 시간을 들여서 접근을 해야 한다는 것이었다. 책들을 읽으며 많이 공감됐었던 사례나 나쁜 예시들이 나의 이야기와 같은 경우도 있기도 했었다. 내가 등한시했던 부분들이 보완이나 변경을 해야 한다고 나왔을 때 부끄럽기도 했었지만 솔루션이 책에 나와있고 이부분들을 익히면 나의 코드 또한 발전할 것이라는 믿음에 기쁘기도 하였다. 책을 한번 읽는다고 익혀지는 사람은 없다고 생각하고 있다. 항상 틈이 있을 때 마다 보고 다시 상기시키며 앞으로의 프로젝트들을 수행하겠다고 다짐한다.

